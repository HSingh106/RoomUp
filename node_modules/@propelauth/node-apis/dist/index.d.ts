type CreateAccessTokenRequest = {
    userId: string;
    durationInMinutes: number;
};
type AccessToken = {
    access_token: string;
};

type CreateMagicLinkRequest = {
    email: string;
    redirectToUrl?: string;
    expiresInHours?: number;
    createNewUserIfOneDoesntExist?: boolean;
};
type MagicLink = {
    url: string;
};

type CustomRoleMappings = {
    customRoleMappings: CustomRoleMapping[];
};
type CustomRoleMapping = {
    customRoleMappingName: string;
    numOrgsSubscribed: number;
};

type SocialLoginProvider = "Google" | "GitHub" | "Microsoft" | "Slack" | "LinkedIn" | "Salesforce" | "Xero" | "QuickBooks Online";
type SamlLoginProvider = "Google" | "Rippling" | "OneLogin" | "JumpCloud" | "Okta" | "Azure" | "Duo" | "Generic";
type LoginMethod = {
    loginMethod: "password";
} | {
    loginMethod: "magic_link";
} | {
    loginMethod: "social_sso";
    provider: SocialLoginProvider;
} | {
    loginMethod: "email_confirmation_link";
} | {
    loginMethod: "saml_sso";
    provider: SamlLoginProvider;
    orgId: string;
} | {
    loginMethod: "impersonation";
} | {
    loginMethod: "generated_from_backend_api";
} | {
    loginMethod: "unknown";
};
type InternalLoginMethod = {
    login_method: "password";
} | {
    login_method: "magic_link";
} | {
    login_method: "social_sso";
    provider: SocialLoginProvider;
} | {
    login_method: "email_confirmation_link";
} | {
    login_method: "saml_sso";
    provider: SamlLoginProvider;
    org_id: string;
} | {
    login_method: "impersonation";
} | {
    login_method: "generated_from_backend_api";
} | {
    login_method: "unknown";
};

type UserProperties = {
    [key: string]: unknown;
};
type User = {
    userId: string;
    orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo;
    email: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    legacyUserId?: string;
    impersonatorUserId?: string;
    metadata?: {
        [key: string]: any;
    };
    properties?: UserProperties;
    loginMethod: LoginMethod;
    activeOrgId?: string;
};
declare class UserClass {
    userId: string;
    orgIdToUserOrgInfo?: {
        [orgId: string]: OrgMemberInfo;
    };
    email: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    properties?: UserProperties;
    loginMethod: LoginMethod;
    activeOrgId?: string;
    legacyUserId?: string;
    impersonatorUserId?: string;
    constructor(user: User);
    getActiveOrg(): OrgMemberInfo | undefined;
    getActiveOrgId(): string | undefined;
    getOrg(orgId: string): OrgMemberInfo | undefined;
    getOrgByName(orgName: string): OrgMemberInfo | undefined;
    getUserProperty(key: string): unknown | undefined;
    getOrgs(): OrgMemberInfo[];
    isImpersonating(): boolean;
    isRole(orgId: string, role: string): boolean;
    isAtLeastRole(orgId: string, role: string): boolean;
    hasPermission(orgId: string, permission: string): boolean;
    hasAllPermissions(orgId: string, permissions: string[]): boolean;
    static fromUser(user: User): UserClass;
}
type Org = {
    orgId: string;
    name: string;
    maxUsers?: number;
    isSamlConfigured: boolean;
    legacyOrgId?: string;
    metadata: {
        [key: string]: any;
    };
    customRoleMappingName?: string;
};
type Organization = {
    orgId: string;
    name: string;
    urlSafeOrgSlug: string;
    canSetupSaml: boolean;
    isSamlConfigured: boolean;
    isSamlInTestMode: boolean;
    maxUsers?: number;
    metadata?: {
        [key: string]: any;
    };
    domain?: string;
    domainAutojoin: boolean;
    domainRestrict: boolean;
    customRoleMappingName?: string;
    legacyOrgId?: string;
};
type CreatedOrg = {
    orgId: string;
    name: string;
};
type CreatedUser = {
    userId: string;
};
type UserMetadata = {
    userId: string;
    email: string;
    emailConfirmed: boolean;
    hasPassword: boolean;
    username?: string;
    firstName?: string;
    lastName?: string;
    pictureUrl?: string;
    locked: boolean;
    enabled: boolean;
    mfaEnabled: boolean;
    canCreateOrgs: boolean;
    createdAt: number;
    lastActiveAt: number;
    orgIdToOrgInfo?: OrgIdToOrgMemberInfo;
    legacyUserId?: string;
    impersonatorUserId?: string;
    metadata?: {
        [key: string]: any;
    };
    properties?: {
        [key: string]: unknown;
    };
};
declare class OrgMemberInfo {
    readonly orgId: string;
    readonly orgName: string;
    readonly orgMetadata: {
        [key: string]: unknown;
    };
    readonly urlSafeOrgName: string;
    readonly orgRoleStructure: OrgRoleStructure;
    readonly legacyOrgId?: string;
    readonly userAssignedRole: string;
    readonly userInheritedRolesPlusCurrentRole: string[];
    readonly userPermissions: string[];
    readonly userAssignedAdditionalRoles: string[];
    constructor(orgId: string, orgName: string, orgMetadata: {
        [key: string]: any;
    }, urlSafeOrgName: string, userAssignedRole: string, userInheritedRolesPlusCurrentRole: string[], userPermissions: string[], orgRoleStructure?: OrgRoleStructure, userAssignedAdditionalRoles?: string[], legacyOrgId?: string);
    get assignedRole(): string;
    get permissions(): string[];
    get inheritedRolesPlusCurrentRole(): string[];
    isRole(role: string): boolean;
    isAtLeastRole(role: string): boolean;
    hasPermission(permission: string): boolean;
    hasAllPermissions(permissions: string[]): boolean;
    static fromJSON(json: string): OrgMemberInfo;
}
type UserAndOrgMemberInfo = {
    user: User;
    orgMemberInfo: OrgMemberInfo;
};
type OrgIdToOrgMemberInfo = {
    [orgId: string]: OrgMemberInfo;
};
declare enum OrgRoleStructure {
    SingleRole = "single_role_in_hierarchy",
    MultiRole = "multi_role"
}
type InternalOrgMemberInfo = {
    org_id: string;
    org_name: string;
    org_metadata: {
        [key: string]: any;
    };
    url_safe_org_name: string;
    org_role_structure: OrgRoleStructure;
    user_role: string;
    inherited_user_roles_plus_current_role: string[];
    user_permissions: string[];
    additional_roles: string[];
    legacy_org_id?: string;
};
type InternalUser = {
    user_id: string;
    org_id_to_org_member_info?: {
        [org_id: string]: InternalOrgMemberInfo;
    };
    org_member_info?: InternalOrgMemberInfo;
    email: string;
    first_name?: string;
    last_name?: string;
    username?: string;
    metadata?: {
        [key: string]: any;
    };
    properties?: {
        [key: string]: unknown;
    };
    login_method?: InternalLoginMethod;
    legacy_user_id?: string;
    impersonator_user_id?: string;
};
declare function toUser(snake_case: InternalUser): User;
declare function toOrgIdToOrgMemberInfo(snake_case?: {
    [org_id: string]: InternalOrgMemberInfo;
}): OrgIdToOrgMemberInfo | undefined;
type ApiKeyNew = {
    apiKeyId: string;
    apiKeyToken: string;
};
type ApiKeyFull = {
    apiKeyId: string;
    createdAt: number;
    expiresAtSeconds: number;
    metadata: {
        [key: string]: any;
    };
    userId: string;
    orgId: string;
};
type ApiKeyResultPage = {
    apiKeys: ApiKeyFull[];
    totalApiKeys: number;
    currentPage: number;
    pageSize: number;
    hasMoreResults: boolean;
};
type ApiKeyValidation = {
    metadata?: {
        [key: string]: any;
    };
    user?: UserMetadata;
    org?: Org;
    userInOrg?: OrgMemberInfo;
};
type PersonalApiKeyValidation = {
    metadata?: {
        [key: string]: any;
    };
    user: UserMetadata;
};
type OrgApiKeyValidation = {
    metadata?: {
        [key: string]: any;
    };
    org: Org;
    user?: UserMetadata;
    userInOrg?: OrgMemberInfo;
};

type FetchPendingInvitesParams = {
    orgId?: string;
    pageSize?: number;
    pageNumber?: number;
};
type PendingInvite = {
    inviteeEmail: string;
    orgId: string;
    orgName: string;
    roleInOrg: string;
    additionalRolesInOrg: string[];
    createdAt: number;
    expiresAt: number;
    inviterEmail?: string;
    inviterUserId?: string;
};
type PendingInvitesPage = {
    totalInvites: number;
    currentPage: number;
    pageSize: number;
    hasMoreResults: boolean;
    invites: PendingInvite[];
};
type OrgQuery = {
    pageSize?: number;
    pageNumber?: number;
    orderBy?: "CREATED_AT_ASC" | "CREATED_AT_DESC" | "NAME";
    name?: string;
};
type OrgQueryResponse = {
    orgs: Org[];
    totalOrgs: number;
    currentPage: number;
    pageSize: number;
    hasMoreResults: boolean;
};
type CreateOrgRequest = {
    name: string;
    domain?: string;
    enableAutoJoiningByDomain?: boolean;
    membersMustHaveMatchingDomain?: boolean;
    maxUsers?: number;
    customRoleMappingName?: string;
    legacyOrgId?: string;
};
type AddUserToOrgRequest = {
    userId: string;
    orgId: string;
    role: string;
    additionalRoles?: string[];
};
type ChangeUserRoleInOrgRequest = {
    userId: string;
    orgId: string;
    role: string;
    additionalRoles?: string[];
};
type RemoveUserFromOrgRequest = {
    userId: string;
    orgId: string;
};
type UpdateOrgRequest = {
    orgId: string;
    name?: string;
    canSetupSaml?: boolean;
    maxUsers?: number;
    metadata?: {
        [key: string]: any;
    };
    canJoinOnEmailDomainMatch?: boolean;
    membersMustHaveEmailDomainMatch?: boolean;
    domain?: string;
};
type RevokePendingOrgInviteRequest = {
    inviteeEmail: string;
    orgId: string;
};

type TokenVerificationMetadata = {
    verifierKey: string;
    issuer: string;
};

type UsersQuery = {
    pageSize?: number;
    pageNumber?: number;
    orderBy?: "CREATED_AT_ASC" | "CREATED_AT_DESC" | "LAST_ACTIVE_AT_ASC" | "LAST_ACTIVE_AT_DESC" | "EMAIL" | "USERNAME";
    emailOrUsername?: string;
    includeOrgs?: boolean;
};
type UsersPagedResponse = {
    users: UserMetadata[];
    totalUsers: number;
    currentPage: number;
    pageSize: number;
    hasMoreResults: boolean;
};
type UsersInOrgQuery = {
    orgId: string;
    pageSize?: number;
    pageNumber?: number;
    includeOrgs?: boolean;
    role?: string;
};
type CreateUserRequest = {
    email: string;
    emailConfirmed?: boolean;
    sendEmailToConfirmEmailAddress?: boolean;
    password?: string;
    askUserToUpdatePasswordOnLogin?: boolean;
    username?: string;
    firstName?: string;
    lastName?: string;
    properties?: {
        [key: string]: any;
    };
};
type InviteUserToOrgRequest = {
    orgId: string;
    email: string;
    role: string;
    additionalRoles?: string[];
};
type UpdateUserMetadataRequest = {
    username?: string;
    firstName?: string;
    lastName?: string;
    pictureUrl?: string;
    metadata?: {
        [key: string]: any;
    };
    properties?: {
        [key: string]: any;
    };
    updatePasswordRequired?: boolean;
};
type UpdateUserEmailRequest = {
    newEmail: string;
    requireEmailConfirmation: boolean;
};
type UpdateUserPasswordRequest = {
    password: string;
    askUserToUpdatePasswordOnLogin?: boolean;
};
type UserSignupQueryParams = {
    userSignupQueryParameters: {
        [key: string]: string;
    };
};

type MigrateUserFromExternalSourceRequest = {
    email: string;
    emailConfirmed: boolean;
    existingUserId?: string;
    existingPasswordHash?: string;
    existingMfaBase32EncodedSecret?: string;
    askUserToUpdatePasswordOnLogin?: boolean;
    enabled?: boolean;
    firstName?: string;
    lastName?: string;
    username?: string;
    pictureUrl?: string;
    properties?: {
        [key: string]: any;
    };
};

type ApiKeysQueryRequest = {
    orgId?: string;
    userId?: string;
    userEmail?: string;
    pageSize?: number;
    pageNumber?: number;
};
type ApiKeysCreateRequest = {
    orgId?: string;
    userId?: string;
    expiresAtSeconds?: number;
    metadata?: object;
};
type ApiKeyUpdateRequest = {
    expiresAtSeconds?: number;
    metadata?: string;
};

declare class CreateUserException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class MigrateUserException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class CreateOrgException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class AddUserToOrgException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ChangeUserRoleInOrgException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class RemoveUserFromOrgException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class UpdateOrgException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ForbiddenException extends Error {
    readonly message: string;
    readonly status: number;
    constructor(message: string);
}
declare class MagicLinkCreationException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class AccessTokenCreationException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class UnauthorizedException extends Error {
    readonly message: string;
    readonly status: number;
    constructor(message: string);
}
declare class UnexpectedException extends Error {
    readonly message: string;
    readonly status: number;
    constructor(message: string);
}
declare class UpdateUserEmailException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class UpdateUserPasswordException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class UpdateUserMetadataException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class UserNotFoundException extends Error {
}
declare class ApiKeyValidateException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ApiKeyDeleteException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ApiKeyUpdateException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ApiKeyCreateException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class ApiKeyFetchException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}
declare class BadRequestException extends Error {
    readonly fieldToErrors: {
        [fieldName: string]: string[];
    };
    constructor(message: string);
}

declare function getApis(authUrl: URL, integrationApiKey: string): {
    fetchTokenVerificationMetadata: () => Promise<TokenVerificationMetadata>;
    fetchUserMetadataByUserId: (userId: string, includeOrgs?: boolean) => Promise<UserMetadata | null>;
    fetchUserMetadataByEmail: (email: string, includeOrgs?: boolean) => Promise<UserMetadata | null>;
    fetchUserMetadataByUsername: (username: string, includeOrgs?: boolean) => Promise<UserMetadata | null>;
    fetchBatchUserMetadataByUserIds: (userIds: string[], includeOrgs?: boolean) => Promise<{
        [userId: string]: UserMetadata;
    }>;
    fetchBatchUserMetadataByEmails: (emails: string[], includeOrgs?: boolean) => Promise<{
        [email: string]: UserMetadata;
    }>;
    fetchBatchUserMetadataByUsernames: (usernames: string[], includeOrgs?: boolean) => Promise<{
        [username: string]: UserMetadata;
    }>;
    fetchOrg: (orgId: string) => Promise<Organization | null>;
    fetchOrgByQuery: (orgQuery: OrgQuery) => Promise<OrgQueryResponse>;
    fetchCustomRoleMappings: () => Promise<CustomRoleMappings>;
    fetchUsersByQuery: (usersQuery: UsersQuery) => Promise<UsersPagedResponse>;
    fetchUsersInOrg: (usersInOrgQuery: UsersInOrgQuery) => Promise<UsersPagedResponse>;
    fetchUserSignupQueryParams: (userId: string) => Promise<UserSignupQueryParams | null>;
    createUser: (createUserRequest: CreateUserRequest) => Promise<CreatedUser>;
    updateUserMetadata: (userId: string, updateUserMetadataRequest: UpdateUserMetadataRequest) => Promise<boolean>;
    updateUserEmail: (userId: string, updateUserEmailRequest: UpdateUserEmailRequest) => Promise<boolean>;
    updateUserPassword: (userId: string, updateUserPasswordRequest: UpdateUserPasswordRequest) => Promise<boolean>;
    clearUserPassword: (userId: string) => Promise<boolean>;
    createMagicLink: (createMagicLinkRequest: CreateMagicLinkRequest) => Promise<MagicLink>;
    createAccessToken: (createAccessTokenRequest: CreateAccessTokenRequest) => Promise<AccessToken>;
    migrateUserFromExternalSource: (migrateUserFromExternalSourceRequest: MigrateUserFromExternalSourceRequest) => Promise<CreatedUser>;
    deleteUser: (userId: string) => Promise<boolean>;
    disableUser: (userId: string) => Promise<boolean>;
    enableUser: (userId: string) => Promise<boolean>;
    disableUser2fa: (userId: string) => Promise<boolean>;
    resendEmailConfirmation: (userId: string) => Promise<boolean>;
    enableUserCanCreateOrgs: (userId: string) => Promise<boolean>;
    disableUserCanCreateOrgs: (userId: string) => Promise<boolean>;
    logoutAllUserSessions: (userId: string) => Promise<boolean>;
    createOrg: (createOrgRequest: CreateOrgRequest) => Promise<CreatedOrg>;
    addUserToOrg: (addUserToOrgRequest: AddUserToOrgRequest) => Promise<boolean>;
    changeUserRoleInOrg: (changeUserRoleInOrgRequest: ChangeUserRoleInOrgRequest) => Promise<boolean>;
    removeUserFromOrg: (removeUserFromOrgRequest: RemoveUserFromOrgRequest) => Promise<boolean>;
    updateOrg: (updateOrgRequest: UpdateOrgRequest) => Promise<boolean>;
    subscribeOrgToRoleMapping: (orgId: string, customRoleMappingName: string) => Promise<boolean>;
    deleteOrg: (orgId: string) => Promise<boolean>;
    allowOrgToSetupSamlConnection: (orgId: string) => Promise<boolean>;
    disallowOrgToSetupSamlConnection: (orgId: string) => Promise<boolean>;
    inviteUserToOrg: (inviteUserToOrgRequest: InviteUserToOrgRequest) => Promise<boolean>;
    fetchPendingInvites: (params?: FetchPendingInvitesParams) => Promise<PendingInvitesPage>;
    revokePendingOrgInvite: (revokePendingOrgInviteRequest: RevokePendingOrgInviteRequest) => Promise<boolean>;
    fetchApiKey: (apiKeyId: string) => Promise<ApiKeyFull>;
    fetchCurrentApiKeys: (apiKeyQuery: ApiKeysQueryRequest) => Promise<ApiKeyResultPage>;
    fetchArchivedApiKeys: (apiKeyQuery: ApiKeysQueryRequest) => Promise<ApiKeyResultPage>;
    createApiKey: (apiKeyCreate: ApiKeysCreateRequest) => Promise<ApiKeyNew>;
    updateApiKey: (apiKeyId: string, ApiKeyUpdate: ApiKeyUpdateRequest) => Promise<boolean>;
    deleteApiKey: (apiKeyId: string) => Promise<boolean>;
    validateApiKey: (apiKeyToken: string) => Promise<ApiKeyValidation>;
    validatePersonalApiKey: (apiKeyToken: string) => Promise<PersonalApiKeyValidation>;
    validateOrgApiKey: (apiKeyToken: string) => Promise<OrgApiKeyValidation>;
};

declare function parseSnakeCaseToCamelCase(response: string): any;

export { AccessToken, AccessTokenCreationException, AddUserToOrgException, AddUserToOrgRequest, ApiKeyCreateException, ApiKeyDeleteException, ApiKeyFetchException, ApiKeyFull, ApiKeyNew, ApiKeyResultPage, ApiKeyUpdateException, ApiKeyUpdateRequest, ApiKeyValidateException, ApiKeyValidation, ApiKeysCreateRequest, ApiKeysQueryRequest, BadRequestException, ChangeUserRoleInOrgException, ChangeUserRoleInOrgRequest, CreateAccessTokenRequest, CreateMagicLinkRequest, CreateOrgException, CreateOrgRequest, CreateUserException, CreateUserRequest, CreatedOrg, CreatedUser, CustomRoleMapping, CustomRoleMappings, FetchPendingInvitesParams, ForbiddenException, InternalOrgMemberInfo, InternalUser, InviteUserToOrgRequest, LoginMethod, MagicLink, MagicLinkCreationException, MigrateUserException, MigrateUserFromExternalSourceRequest, Org, OrgApiKeyValidation, OrgIdToOrgMemberInfo, OrgMemberInfo, OrgQuery, OrgQueryResponse, OrgRoleStructure, Organization, PendingInvite, PendingInvitesPage, PersonalApiKeyValidation, RemoveUserFromOrgException, RemoveUserFromOrgRequest, RevokePendingOrgInviteRequest, SamlLoginProvider, SocialLoginProvider, TokenVerificationMetadata, UnauthorizedException, UnexpectedException, UpdateOrgException, UpdateOrgRequest, UpdateUserEmailException, UpdateUserEmailRequest, UpdateUserMetadataException, UpdateUserMetadataRequest, UpdateUserPasswordException, UpdateUserPasswordRequest, User, UserAndOrgMemberInfo, UserClass, UserMetadata, UserNotFoundException, UserProperties, UserSignupQueryParams, UsersInOrgQuery, UsersPagedResponse, UsersQuery, getApis, parseSnakeCaseToCamelCase, toOrgIdToOrgMemberInfo, toUser };
